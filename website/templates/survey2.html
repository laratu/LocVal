<!DOCTYPE html>
<html>

    <head>
        <meta charset="utf-8">
        <title>Survey Part 2 (WTP WTA, Data sharing company, Privacy Concern, Perceived Intrusions, Open Questions, Demographics)</title>
        <!--<link rel="stylesheet" href="./css/bootstrap.min.css">-->
        <link rel="stylesheet" href="css/style.css">

        <script>

            //this variable needs to be adjusted depending on where the server is hosted
            // example1 (local):
            let HOST = "http://127.0.0.1:5000"
            // hosting in on a server:
            //let HOST = <name of HOST Adress>

        </script>
<style>
    html {
    font-family: Arial, Helvetica, sans-serif;
}



.label{
  font-size:0.5em; 
}

body {
    width: 100%;
    text-align: center;
    font-size: 1.2rem;
    font-weight: 400;
    line-height: 1.5;
    color: #55595c;
    background-color: #fff;
    -webkit-text-size-adjust: 100%;
    -webkit-tap-highlight-color: #573b8a;
    margin: 0px;
    position: absolute;
 }

 body > div{
    position: relative;
    padding: 3em;
 }

  tbody{
    color: #a079e8;
    width:100%;
    display: inline-table;
    font-size: 1rem;
  }

hr {
    border: 0.1px solid rgba(87, 59, 138, 0.2);
  }


  h1, .h1, h3, .h3{
    
    margin-bottom:2rem;
    font-weight: 600;
    line-height: 1.2;
    color: #1a1a1a;
  }
  
  h2, .h2{
    margin-bottom:2rem;
    font-weight: 500;
    line-height: 1.2;
    color: #1a1a1a;
  }

  h4, .h4{
    text-align: left !important;
    margin-bottom:2rem;
    font-weight: 600;
    line-height: 1.2;
    color: #1a1a1a;
  }
  
  h1, .h1 {
    font-size: calc(1.325rem + 0.9vw);
  }
  

  b1{
    color: #573b8a;
    font-weight: bold
  }
  
  /*Styling der Input Elemente*/
  :focus:not([type="radio"]){
    transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
    box-shadow: 0 0 0 0.25rem rgb(0, 0, 0);
    outline: none !important;
    border: none;
  }
  
  
  
  /*Styling des Button*/
  button, [type="button"]{
    margin-top: 2em;
    margin-bottom: 1em;
    border-color: #573b8a;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    padding: 0.75rem 1.5rem;
    font-size: 1rem;
    cursor: pointer;
    transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
    background-color: #573b8a;
    color: #573b8a;
    background-color: transparent;
    border-radius: 0.5em;
  }
  
  button:hover, [type="button"]:hover{
    color: white;
    background-color: #573b8a;
  }
  
  button:focus, [type="button"]:focus{
    box-shadow: 0 0 0 0.25rem rgba(26, 26, 26, 0.5);
  }
  
  
  

  
  
  
  /*Kästen um die Fragebogenelemente*/
  .questionnaireItem {
    font-size: large;
    margin-top: 4em;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 0.1rem 1rem #573b8a;
    border-radius: 0.5em;
    padding: 2em;
  }

  
  /*Fragebogenelement ist erforderlich*/
  .Required,
  .questionnaireItemRequired {
    font-size: large;
    outline: none;
    border-color: #cc5858;
    box-shadow: 0 0 0 0.25rem #f3bdbc;
  }

  @media only screen and (max-width: 720px) {
    body{
        width: 100%
    }

    body > div{
        margin: 1em;
    }

    body > div > div.questionnaireItem{
        position: relative;
        padding: 20px;
        width: auto;                    
    }
    tbody{
        margin: 0;
        position: relative;
    }
  }
</style>

        <script src="js/thefragebogen.js"></script>

        <script>

function downloadData(filename, data) {
    if (typeof(window.navigator.msSaveBlob) === "function") {
        const blob = new Blob([data], {
            type: "text/plain"
        });
        window.navigator.msSaveBlob(blob, filename);
        return;
    }
    if ("download" in document.createElement("a") && navigator.userAgent.toLowerCase().indexOf("firefox") === -1) { //So far only chrome AND not firefox.
        const downloadLink = document.createElement("a");
        downloadLink.download = filename;
        downloadLink.href = window.URL.createObjectURL(new Blob([data], {
            type: "text/plain"
        }));
        downloadLink.click();
        window.URL.revokeObjectURL(downloadLink.href); //Release object: https://developer.mozilla.org/en-US/docs/Web/API/URL.revokeObjectURL
        return;
    }
    window.location.href = "data:application/x-download;charset=utf-8," + encodeURIComponent(data);
}

/**
Defines a message that should be logged, consisting of level, location, and the content.
The messages _should_ be subdivided in five types according to their relevance:
1. Fatal
2. Error
3. Warn
4. Info
5. Debug

DEVELOPER: This class is used internally by LogConsole and should not be accessed directly.

@class LogMessage
*/
class LogMessage {

    /**
    @param {string} logLevel type of message
    @param {string} location location in the code
    @param {string} msg the message itself
    */
    constructor(logLevel, location, msg) {
        this.logLevel = "" + logLevel;
        this.location = "" + location;
        this.msg = msg;
    }
}

/**
Provides basic logging functionality (prints to console).

DEVELOPER: All the messages (instances of class `LogMessage`) are saved in an array and can be accessed via `TheFragebogen.logger.logMessages` as long as this logger is used.

@class LogConsole
*/
class LogConsole {

    constructor() {
        this.logMessages = [];
        this.debug("LogConsole.constructor()", "Start");
    }

    debug(location, msg) {
        this.logMessages.push(new LogMessage("DEBUG", location, msg));
        if (console.debug === undefined) {
            //For IE console.debug is not defined.
            console.debug = console.log;
        }
        console.debug("DEBUG: " + location + ": " + msg);
    }

    info(location, msg) {
        this.logMessages.push(new LogMessage("INFO", location, msg));
        console.info("INFO: " + location + ": " + msg);
    }

    warn(location, msg) {
        this.logMessages.push(new LogMessage("WARN", location, msg));
        console.warn("WARN: " + location + ": " + msg);
    }

    error(location, msg) {
        this.logMessages.push(new LogMessage("ERROR", location, msg));
        console.error("ERROR: " + location + ": " + msg);
    }

    fatal(location, msg) {
        this.logMessages.push(new LogMessage("FATAL", location, msg));
        console.error("FATAL: " + location + ": " + msg);
    }
}

/**
 Defines the accessor for the logger.
 Can be redefined later if desired.
*/
const TheFragebogen = {
    logger: new LogConsole()
};

/**
Provides a UI for pagination between `Screens`.
Only provides a set of API that must be implemented by childs.

@abstract
@class PaginateUI
*/
class PaginateUI {

    /**
    @param {string} [className] CSS class
    */
    constructor(className) {
        this.className = className;

        this.paginateCallback = null;
    }

    /**
    Creates the UI of the element.
    @abstract
    @return {object}
    */
    createUI() {
        TheFragebogen.logger.debug(this.constructor.name + ".createUI()", "This method must be overridden.");
    }

    /**
    Destroys the UI.
    @abstract
    */
    releaseUI() {
        TheFragebogen.logger.debug(this.constructor.name + ".releaseUI()", "This method might need to be overridden.");
    }

    /**
    Sets callback to get informed when loading of all required external data is finished.
    @param {Function}
    @return {boolean}
    */
    setPaginateCallback(paginateCallback) {
        if (!(paginateCallback instanceof Function)) {
            TheFragebogen.logger.error(this.constructor.name + ".setPaginateCallback()", "No callback handle given.");
            return false;
        }

        TheFragebogen.logger.debug(this.constructor.name + ".setPaginateCallback()", "called");
        this.paginateCallback = paginateCallback;
        return true;
    }

    /**
    Sends this.paginateCallback() to paginate to the desired Screen.
    @param {Number} relativeScreenId The screen to paginate to as relative index.
    @return {boolean}
    */
    _sendPaginateCallback(relativeScreenId) {
        if (!(this.paginateCallback instanceof Function)) {
            TheFragebogen.logger.warn(this.constructor.name + "._sendPaginateCallback()", "called, but no paginateCallback set.");
            return false;
        }
        this.paginateCallback(relativeScreenId);
    }

    /**
    @return {string} Returns a string representation of this object.
    @abstract
    */
    toString() {
        TheFragebogen.logger.debug(this.constructor.name + ".toString()", "This method might need to be overridden.");
    }
}

/**
A Screen is a UI component that shows a UI.
It represents a sheet of paper containing several items of a questionnaire.
In TheFragebogen only one screen is shown at a time.

@abstract
@class Screen
*/
class Screen {

    /**
    @param {string} [className] CSS class
    */
    constructor(className) {
        this.className = className;

        this.paginateCallback = null;
        this.preloadedCallback = null;
        this.preloaded = true;

        this.node = null;
    }

    /**
    @returns {boolean} true if the UI is created, false if not
    */
    isUIcreated() {
        return this.node !== null;
    }

    /**
    Creates the UI.
    @abstract
    */
    createUI() {}

    /**
    Applies the set className.
    Usually called during createUI().
    */
    applyCSS() {
        if (this.isUIcreated() && this.className !== undefined) {
            this.node.className = this.className;
        }
    }

    /**
    (optional) Inform the screen its UI gets shown.
    @abstract
    */
    start() {}

    /**
    Destroy and release the UI.
    */
    releaseUI() {
        TheFragebogen.logger.info(this.constructor.name + ".releaseUI()", "");
        this.node = null;
    }

    /**
    Returns the stored data.
    @abstract
    @returns {array<array>}
    */
    getData() {}

    /**
    Set the callback for ready-state changed.
    @param {function} [callback]
    */
    setPaginateCallback(callback) {
        if (!(callback instanceof Function)) {
            TheFragebogen.logger.error(this.constructor.name + ".setPaginateCallback()", "Provided callback ist not a function.");
            return false;
        }

        TheFragebogen.logger.debug(this.constructor.name + ".setPaginateCallback()", "called.");
        this.paginateCallback = callback;
        return true;
    }

    /**
    Call this.paginateCallback().
    @param {number} [relativeScreenId=1] The relative id of the next screen.
    @param {boolean} [isReadyRequired=true] Only send the event if `this.isReady() === true`.
    */
    _sendPaginateCallback(relativeScreenId, isReadyRequired) {
        relativeScreenId = relativeScreenId === undefined ? 1 : relativeScreenId;
        isReadyRequired = isReadyRequired === undefined ? true : isReadyRequired;

        if (!(this.paginateCallback instanceof Function)) {
            TheFragebogen.logger.error(this.constructor.name + "._sendPaginateCallback()", "called, but no paginateCallback set.");
            return;
        }

        if (isReadyRequired && !this.isReady()) {
            TheFragebogen.logger.info(this.constructor.name + "._sendPaginateCallback()", "called while screen is not ready but isReadyRequired is set.");
            return;
        }

        TheFragebogen.logger.debug(this.constructor.name + "._sendPaginateCallback()", "called");
        this.paginateCallback(this, relativeScreenId);
    }

    /**
    Is the screen ready and TheFragebogen can continue to the next one?
    @abstract
    @returns {boolean} true Is the screen ready?
    */
    isReady() {
        return true;
    }

    /**
    Sets the `PaginateUI` for the screen.
    NOTE: Can only be called successfully if `screen.createUI()` is `false`.
    NOTE: This function is _only_ implemented by screens that provide _manual_ pagination.
    @abstract
    @param {function} [paginateUI] Set the `PaginateUI` to be used. Set `null` for no `paginateUI`.
    @returns {boolean} Setting the PaginateUI was successful?
    */
    setPaginateUI(paginateUI) {
        TheFragebogen.logger.warn(this.constructor.name + ".setPaginateUI()", "This method might need to be overridden.");
        return false;
    }

    /**
    Starts preloading external media.
    Default implementation immediately sends callback `Screen._sendOnPreloadedCallback()`.
    @abstract
    */
    preload() {
        TheFragebogen.logger.debug(this.constructor.name + ".preload()", "Must be overridden for preloading.");
        this._sendOnPreloadedCallback();
    }

    /**
    All external resources loaded?
    @abstract
    @returns {boolean}
    */
    isPreloaded() {
        return this.preloaded;
    }

    /**
     Calls the function defined by setOnPreloadedCallback()
     */
    _sendOnPreloadedCallback() {
        if (!(this.preloadedCallback instanceof Function)) {
            TheFragebogen.logger.error(this.constructor.name + "._sendOnPreloadedCallback()", "called, but no preloadedCallback set.");
            return;
        }
        this.preloadedCallback();
    }

    /**
     Sets a preloadedCallback function to be called when screen preloading
     is finished.
     */
    setOnPreloadedCallback(preloadedCallback) {
        if (!(preloadedCallback instanceof Function)) {
            TheFragebogen.logger.error(this.constructor.name + ".setOnPreloadedCallback()", "No callback handle given.");
            return false;
        }

        TheFragebogen.logger.debug(this.constructor.name + ".setOnPreloadedCallback()", "called");
        this.preloadedCallback = preloadedCallback;
        return true;
    }
}

/**
A ScreenController coordinates a questionnaire, i.e., showing a set of Screens and storing the gathered data.
This ScreenController shows the Screens in a predefined order.
Applies lifecycle management for the Screens.

ATTENTION: `ScreenController.init(parentNode)` must be called before using a ScreenController.

Callbacks:
* ScreenController.callbackScreenFinished() {boolean}: The current screen is done; continue to next screen?

@class ScreenController
*/
class ScreenController {

    /**
    @param {array} The Screens to be used.
    */
    constructor() {
        if (arguments.length === 0) TheFragebogen.logger.fatal(this.constructor.name + ".constructor", "No screen available.");

        const localArguments = [].concat.apply([], arguments); //Flatten the potential array.

        for (let i = 0; i < localArguments.length; i++) {
            if (!(localArguments[i] instanceof Screen)) TheFragebogen.logger.error(this.constructor.name + "()", "This argument (index " + i + " is not a Screen: " + localArguments[i] + " and will be ignored.");
        }
        this.screen = [];
        const screenList = localArguments.filter((element) => element instanceof Screen);
        for (let i = 0; i < screenList.length; i++) {
            this.addScreen(screenList[i]);
        }

        this.callbackScreenFinished = null;

        this.currentScreenIndex = null;
        this.screenContainerNode = null;

        this.preloadedScreenResult = null;
    }

    /**
    Init this instance of ScreenController; most important providing the HTML element to be used.
    @param {HTMLElement} [parentNode] The parent HTML element; must be a container.
    */
    init(parentNode) {
        if (this.screenContainerNode !== null) {
            TheFragebogen.logger.warn(this.constructor.name + ".init()", "Is already initialized.");
            return;
        }

        TheFragebogen.logger.debug(this.constructor.name + ".init()", "Start");

        this.screenContainerNode = parentNode;

        this.currentScreenIndex = 0;
    }

    setCallbackScreenFinished(callback) {
        if (!(callback instanceof Function)) {
            TheFragebogen.logger.warn(this.constructor.name + ".setCallbackScreenFinished()", "Callback is not a function. Ignoring it.");
            return;
        }
        this.callbackScreenFinished = callback;
    }

    /**
    Add an additional screen at the end.
    @param {Screen} screen
    @returns {number} The index of the just added screen; in case of failure -1.
    */
    addScreen(screen) {
        if (!(screen instanceof Screen)) {
            TheFragebogen.logger.warn(this.constructor.name + ".addScreen()", "This screen is not a screen. Ignoring it.");
            return -1;
        }

        TheFragebogen.logger.info(this.constructor.name + ".addScreen()", "Appending screen.");
        this.screen.push(screen);

        if (screen.setGetDataCallback instanceof Function) {
            screen.setGetDataCallback((includeAnswerChangelog) => this.requestDataCSV(includeAnswerChangelog));
        }
        if (screen.setGetRawDataCallback instanceof Function) {
            screen.setGetRawDataCallback((includeAnswerChangelog) => this.requestDataArray(includeAnswerChangelog));
        }
        if (screen.setPaginateCallback instanceof Function) {
            screen.setPaginateCallback((screen, relativeScreenId) => this.nextScreen(screen, relativeScreenId));
        }

        return this.screen.length - 1;
    }

    /**
     */

    /**
    Starts the screenController, i.e., showing the screen in their respective order.
    */
    start() {
        this.screenContainerNode.innerHTML = "";
        this._displayUI();
    }

    /**
    Proceeds to the next screen if the current screen reports ready.
    @param {Screen} screen The screen that send the callback.
    @param {number} [relativeScreenId=1]
    */
    nextScreen(screen, relativeScreenId) {
        if (this.screenContainerNode === null) {
            TheFragebogen.logger.error(this.constructor.name + ".nextScreen()", "Please call init() before.");
            return;
        }

        if (!(screen instanceof Screen)) {
            TheFragebogen.logger.error(this.constructor.name + ".nextScreen()", "Got a callback without a screen.");
            return;
        }

        if (screen !== this.screen[this.currentScreenIndex]) {
            TheFragebogen.logger.error(this.constructor.name + ".nextScreen()", "Got a callback from a different screen than the current one.");
            return;
        }

        if (this.callbackScreenFinished instanceof Function && !this.callbackScreenFinished(relativeScreenId)) { //Should we proceed to the next screen or is this handled by external command?
            return;
        }

        relativeScreenId = relativeScreenId === undefined ? 1 : relativeScreenId;
        this.goToScreenRelative(relativeScreenId);
    }

    _displayUI() {
        if (this.currentScreenIndex >= this.screen.length) {
            TheFragebogen.logger.error(this.constructor.name + "._displayUI()", "There is no screen with index " + this.currentScreenIndex + ".");
            return;
        }

        TheFragebogen.logger.info(this.constructor.name + "._displayUI()", "Displaying next screen with index: " + this.currentScreenIndex + ".");

        //Scroll back to top
        window.scrollTo(0, document.body.scrollLeft);

        //Add the new screen
        const screen = this.screen[this.currentScreenIndex];
        this.screenContainerNode.appendChild(screen.createUI());
        screen.start();
    }

    /**
    Prepare data for export (CSV).
    * Column 1: ScreenIndex
    * Column 2: Class
    * Column 3: Questions
    * Column 4: Answer options
    * Column 5: JSON.stringify(Answers || Answer changelog)
    @param {boolean} [includeAnswerChangelog=false] Should the the changelog of the answer be reported?
    @return {string}
    */
    requestDataCSV(includeAnswerChangelog) {
        TheFragebogen.logger.info(this.constructor.name + ".requestDataCSV()", "called.");
        const dataArray = this.requestDataArray(includeAnswerChangelog);

        let result = "";
        for (let i = 0; i < dataArray.length; i++) {
            result += '"' + dataArray[i][0]; //Screen index
            result += '","' + dataArray[i][1]; //Type of question
            result += '","' + dataArray[i][2]; //Question
            result += '","' + dataArray[i][3]; //Answer options
            result += '",' + JSON.stringify(dataArray[i][4]) + '\n'; //Answer
        }
        return result;
    }

    /**
    Prepare data for export as a two-dimensional array:
    * Column 1: ScreenIndex
    * Column 2: Class
    * Column 3: Questions
    * Column 4: Answer options
    * Column 5: Answers || Answer changelog
    @param {boolean} [includeAnswerChangelog=false] Should the the changelog of the answer be reported?
    @return {array}
    */
    requestDataArray(includeAnswerChangelog) {
        TheFragebogen.logger.info(this.constructor.name + ".requestDataArray()", "called.");

        let screenIndeces = ["Screen index"];
        let questionType = ["Type of item"];
        let questions = ["Question"];
        let options = ["Answer options"];
        let answers = ["Answer"];

        for (let i = 0; i <= this.currentScreenIndex; i++) {
            const currentData = this.screen[i].getData(includeAnswerChangelog);

            if (currentData instanceof Array && currentData[0] instanceof Array && currentData[1] instanceof Array && currentData[2] instanceof Array && currentData[3] instanceof Array) {
                if (currentData[0].length === 0) continue;

                if (currentData[1].length > currentData[3].length) {
                    TheFragebogen.logger.warn(this.constructor.name + ".requestDataArray()", "More items than answers - filling with null.");
                    currentData[1][currentData[0].length] = null;
                }

                for (let j = 0; j < currentData[0].length; j++) {
                    screenIndeces = screenIndeces.concat(i);
                }

                questionType = questionType.concat(currentData[0]);
                questions = questions.concat(currentData[1]);
                options = options.concat(currentData[2]);
                answers = answers.concat(currentData[3]);
            }
        }

        let result = [];
        for (let i = 0; i < screenIndeces.length; i++) {
            result[i] = [];
            result[i][0] = screenIndeces[i];
            result[i][1] = questionType[i];
            result[i][2] = questions[i];
            result[i][3] = options[i];
            result[i][4] = answers[i];
        }

        //Replace line breaks.
        result = result.map(function(line) {
            return line.map(function(cell) {
                return (typeof(cell) === "string") ? cell.replace(/\n/g, '\\n') : cell;
            });
        });

        return result;
    }

    /**
    @return {boolean}
    */
    isLastScreen() {
        return this.currentScreenIndex === this.screen.length - 1;
    }

    /*
    @return {number}
    */
    getCurrentScreenIndex() {
        return this.currentScreenIndex;
    }

    /*
    @return {Screen}
    */
    getCurrentScreen() {
        return this.screen[this.getCurrentScreenIndex()];
    }

    /**
    Go to screen by screenId (relative).
    @argument {number} relativeScreenId The screenId (relative) of the screen that should be displayed.
    @return {boolean} Success.
    */
    goToScreenRelative(relativeScreenId) {
        if (this.screenContainerNode === null) {
            TheFragebogen.logger.error(this.constructor.name + ".goToScreenRelative()", "Please call init() before.");
            return false;
        }

        if (this.getCurrentScreenIndex() == this.screen.length - 1 && relativeScreenId == 1) {
            TheFragebogen.logger.warn(this.constructor.name + ".goToScreenRelative()", "Reached the last screen and there is no next screen to proceed to.");
            return false;
        }

        const screenId = this.getCurrentScreenIndex() + relativeScreenId;

        if (!(0 <= screenId && screenId < this.screen.length)) {
            TheFragebogen.logger.error(this.constructor.name + ".goToScreenRelative()", "There is no screen with id: " + screenId);
            return false;
        }

        this.screen[this.currentScreenIndex].releaseUI();
        this.screenContainerNode.innerHTML = null;

        this.currentScreenIndex = screenId;
        this._displayUI();
        return true;
    }

    /**
    Go to screen by screenId (absolute).
    @argument {number} screenId The screenId (relative) of the screen that should be displayed.
    @return {boolean} Success.
    */
    goToScreenAbsolute(screenId) {
        return this.goToScreenRelative(screenId - this.getCurrentScreenIndex());
    }

    /**
    Initiates preloading of external media, i.e., informs all `Screens` to start loading external media and report when ready/fail.
    While preloading, `screenController.start()` can be called.
    @see ScreenController._onPreloadedScreenFinished()
    @see ScreenController._onScreenPreloaded()
    @see ScreenController._finishedPreload()
    @param innerHTML The HTML to be shown while preloading.
    */
    preload(innerHTML) {
        TheFragebogen.logger.debug(this.constructor.name + ".preload()", "Preloading started.");

        this.screenContainerNode.innerHTML += innerHTML;

        for (let i = 0; i < this.screen.length; i++) {
            this.screen[i].setOnPreloadedCallback(() => this.onScreenPreloaded());
            this.screen[i].preload();
        }
    }

    /**
    Handles the returned preloadStatus from each screen.
    @param {Screen} screen The screen that finished preloading.
    */
    onScreenPreloaded() {
        for (let i = 0; i < this.screen.length; i++) {
            if (!this.screen[i].isPreloaded()) {
                return;
            }
        }

        this.onPreloadingDone();
    }

    /**
    Preloading is finished.
    Start the screenController.
    */
    onPreloadingDone() {
        TheFragebogen.logger.info(this.constructor.name + "._onPreloadingDone()", "Preloading done. Let's go.");
        setTimeout(() => this.start(), 2000);
        //TODO Do something about preloading errors?
    }
}

/**
Abstract controller class for generic UI elements.
Only provides a set of API that must be implemented by childs.

@abstract
@class UIElement
*/
class UIElement {

    /**
    @param {string} [className] CSS class
    */
    constructor(className) {
        this.className = className;

        this.uiCreated = false;
        this.enabled = false;
        this.visible = true;
        this.preloaded = true;

        this.preloadedCallback = null;
        this.node = null;
    }

    /**
    @returns {boolean} true if the UI is created, false if not
    */
    isUIcreated() {
        return this.uiCreated;
    }

    /**
    Creates the UI of the element.
    @abstract
    @return {object}
    */
    createUI() {
        TheFragebogen.logger.debug(this.constructor.name + ".createUI()", "This method must be overridden.");
    }

    /**
    Applies the set className.
    Usually called during createUI().
    @param {string} cssSuffix A suffix to be added to this.className.
    */
    applyCSS(cssSuffix) {
        if (this.isUIcreated() && (this.className !== undefined || cssSuffix !== undefined)) {
            let newClassName = "";
            newClassName += this.className !== undefined ? this.className : "";
            newClassName += cssSuffix !== undefined ? cssSuffix : "";
            this.node.className = newClassName;
        }
    }

    /**
    Destroys the UI.
    */
    releaseUI() {
        this.uiCreated = false;
        this.enabled = false;
        this.node = null;
    }

    /**
    @return {boolean} Is the UI of this element enabled?
    */
    isEnabled() {
        return this.enabled;
    }

    /**
    Setting a component to be enabled incl. UI components.
    By default disables all childs of this.node.
    @param {boolean} enabled
    */
    setEnabled(enable) {
        if (!this.isUIcreated()) {
            return;
        }
        this.enabled = enable;

        if (this.node !== null) {
            const elements = this.node.getElementsByTagName("*");
            for (let i = 0; i < elements.length; i++) {
                elements[i].disabled = !this.enabled;
            }
        }
    }

    /**
    @return {boolean} Is the UI of this element visible?
    */
    isVisible() {
        return this.visible;
    }

    /**
    Set UI visible state.
    @param {boolean} visible
    */
    setVisible(visible) {
        if (!this.isUIcreated()) return;

        this.visible = visible;
        this.node.style.visibility = visible ? "visible" : "hidden";
    }


    /**
    @returns {string} The type of this class usually the name of the class.
    */
    getType() {
        return this.constructor.name;
    }

    /**
    @abstract
    @return {boolean} Is the element ready?
    */
    isReady() {
        TheFragebogen.logger.debug(this.constructor.name + ".isReady()", "This method might need to be overridden.");
        return true;
    }

    /**
    Starts preloading external media.
    Default implementation immedately sends callback `Screen._sendOnScreenPreloadedCallback()`.
    @abstract
    */
    preload() {
        TheFragebogen.logger.debug(this.constructor.name + ".preload()", "Must be overridden for preloading.");
        this._sendOnPreloadedCallback();
    }

    /**
    All external resources loaded?
    @returns {boolean}
    */
    isPreloaded() {
        return this.preloaded;
    }

    /**
    Set callback to get informed when loading of all required external data is finished.
    @param {Function}
    @return {boolean}
    */
    setOnPreloadedCallback(preloadedCallback) {
        if (!(preloadedCallback instanceof Function)) {
            TheFragebogen.logger.error(this.constructor.name + ".setOnPreloadedCallback()", "No callback handle given.");
            return false;
        }

        TheFragebogen.logger.debug(this.constructor.name + ".setOnPreloadedCallback()", "called");
        this.preloadedCallback = preloadedCallback;
        return true;
    }

    /**
    Sends this.onPreloadCallback() to signalize that all required data could be loaded.
    @return {boolean}
    */
    _sendOnPreloadedCallback() {
        if (!(this.preloadedCallback instanceof Function)) {
            TheFragebogen.logger.warn(this.constructor.name + "._sendOnPreloadedCallback()", "called, but no onScreenPreloadedCallback set.");
            return false;
        }
        this.preloaded = true;
        this.preloadedCallback();
    }

    /**
    @abstract
    @return {string} Returns a string representation of this object.
    */
    toString() {
        TheFragebogen.logger.debug(this.constructor.name + ".toString()", "This method might need to be overridden.");
    }
}

 /**
Provides a UI for pagination between `Screens`.

Implements a button to continue to the following `Screen`.

@class PaginateUIButton
@augments PaginateUI
*/
 class PaginateUIButton extends PaginateUI {

     /**
     @param {string} [className] CSS class
     @param {number} [relativeIdNext=undefined] The relativeId of the next screen. If undefined, no back button will be generated.
     @param {number} [relativeIdback=undefined] The relativeId of the next screen. If undefined, no back button will be generated.
     @param {string} [labelBack="Back"] The caption for the back-button.
     @param {string} [labelNext="Next"] The caption for the next-button.
     */
     constructor(className, relativeIdBack, relativeIdNext, labelBack, labelNext) {
         super(className);

         this.relativeIdBack = relativeIdBack;
         this.relativeIdNext = relativeIdNext;
         if (this.relativeIdBack === undefined && this.relativeIdNext === undefined) {
             TheFragebogen.logger.error(this.constructor.name + "()", "relativeIdBack and relativeIdNext are undefined. No buttons will be created.");
         }
         if (typeof(this.relativeIdBack) !== "number" && typeof(this.relativeIdNext) !== "number") {
             TheFragebogen.logger.error(this.constructor.name + "()", "relativeIdBack and relativeIdNext should be numbers.");
         }

         this.labelBack = labelBack === undefined ? "Zurück" : labelBack;
         this.labelNext = labelNext === undefined ? "Nächste Seite" : labelNext;

         this.node = null;
     }

     /**
     @returns {boolean} true if the UI is created, false if not
     */
     isUIcreated() {
         return this.uiCreated;
     }

     createUI() {
         this.node = document.createElement("div");
         this.node.className = this.className;

         if (this.relativeIdBack !== undefined) {
             const buttonBack = document.createElement("input");
             buttonBack.type = "button";
             buttonBack.value = this.labelBack;
             buttonBack.addEventListener("click", () => this._sendPaginateCallback(this.relativeIdBack));
             this.node.appendChild(buttonBack);
         }

         if (this.relativeIdNext !== undefined) {
             const buttonNext = document.createElement("input");
             buttonNext.type = "button";
             buttonNext.value = this.labelNext;
             buttonNext.addEventListener("click", () => this._sendPaginateCallback(this.relativeIdNext));
             this.node.appendChild(buttonNext);
         }
         return this.node;
     }

     releaseUI() {
         this.node = null;
     }
 }


/**
A screen that presents one or more UIElements.
All UIElements are visible and enabled by default.
Ready is reported when all UIElements reported ready AND the user pressed the presented button.

Supports _pagination_.
Default paginator is `PaginateUIButton`.

@class ScreenUIElements
@augments Screen
*/
class ScreenUIElements extends Screen {

    /**
    @param {string} [className=] CSS class
    @param {...UIElement} arguments an array containing the UIElements of the screen
    */
    constructor(className) {
        super();

        const localArguments = Array.prototype.slice.call(arguments);

        if (className instanceof String) {
            this.className = className;
            localArguments.splice(0, 1);
        }

        for (let i = 0; i < localArguments.length; i++) {
            if (!(localArguments[i] instanceof UIElement)) {
                TheFragebogen.logger.error(this.constructor.name + "()", "This argument (index " + i + " is not an UIElement: " + localArguments[i]);
            }
        }
        this.uiElements = localArguments.filter((element) => element instanceof UIElement);

        if (this.uiElements.length < 1) {
            TheFragebogen.logger.error(this.constructor.name + "()", "No UIElements were passed to constructor.");
        }

        this.paginateUI = new PaginateUIButton(undefined, undefined, 1);
    }

    setPaginateUI(paginateUI) {
        if (this.isUIcreated()) return false;
        if (!(paginateUI instanceof PaginateUI || paginateUI === null)) return false;

        this.paginateUI = paginateUI;
        TheFragebogen.logger.debug(this.constructor.name + ".setPaginateUI()", "Set paginateUI.");
        return true;
    }

    createUI() {
        this.node = document.createElement("div");
        this.applyCSS();

        for (let i = 0; i < this.uiElements.length; i++) {
            if (this.uiElements[i].createUI === undefined) {
                TheFragebogen.logger.warn(this.constructor.name + ".createUI()", "Element[" + i + "] has no 'createUI' method");
                continue;
            }

            const uiElementNode = this.uiElements[i].createUI();
            if (uiElementNode instanceof HTMLElement) {
                this.node.appendChild(uiElementNode);
            } else {
                TheFragebogen.logger.warn(this.constructor.name + ".createUI()", "Element[" + i + "].createUI() did not a HTMLElement.");
            }
        }

        if (this.paginateUI != null) {
            this.paginateUI.setPaginateCallback((relativeScreenId) => this._sendPaginateCallback(relativeScreenId));
            this.node.appendChild(this.paginateUI.createUI());
        }

        return this.node;
    }

    releaseUI() {
        super.releaseUI();
        for (let i = 0; i < this.uiElements.length; i++) {
            this.uiElements[i].releaseUI();
        }
    }

    /**
    Enables all the elements of the screen.
    */
    start() {
        TheFragebogen.logger.info(this.constructor.name + ".start()", "");

        for (let i = 0; i < this.uiElements.length; i++) {
            this.uiElements[i].setEnabled(true);
        }
    }

    /**
    Are all UIElementInteractive ready?
    @returns {boolean}
    */
    isReady() {
        let ready = true;

        for (let i = 0; i < this.uiElements.length; i++) {
            if (this.uiElements[i] instanceof UIElementInteractive) {
                if (!this.uiElements[i].isReady()) {
                    ready = false;
                }
                this.uiElements[i].markRequired();
            }
        }
        return ready;
    }

    /**
     Returns the data of QuestionnaireItem (UIElementInteractive are omitted) as an two-dimensional array.
     The data of each questionnaire item is subdivided in 4 columns:
     1. QuestionnaireItem.getType()
     2. QuestionnaireItem.getQuestion()
     3. QuestionnaireItem.getAnswerOptions()
     4. QuestionnaireItem.getAnswer() || QuestionnaireItem.getAnswerChangelog()
     @param {boolean} includeAnswerChangelog Should the the changelog of the answer be reported?
     @returns {array}
     */
    getData(includeAnswerChangelog) {
        const data = [
            [],
            [],
            [],
            []
        ];

        for (let i = 0; i < this.uiElements.length; i++) {
            if ((this.uiElements[i] instanceof QuestionnaireItem)) {
                data[0].push(this.uiElements[i].getType());
                data[1].push(this.uiElements[i].getQuestion());
                data[2].push(this.uiElements[i].getAnswerOptions());
                if (includeAnswerChangelog) {
                    data[3].push(this.uiElements[i].getAnswerChangelog());
                } else {
                    data[3].push(this.uiElements[i].getAnswer());
                }
            }
        }
        return data;
    }

    preload() {
        TheFragebogen.logger.debug(this.constructor.name + ".preload()", "called");

        for (let i = 0; i < this.uiElements.length; i++) {
            this.uiElements[i].setOnPreloadedCallback(() => this._onUIElementPreloaded());
            this.uiElements[i].preload();
        }
    }

    /**
    All external resources loaded?
    @abstract
    @returns {boolean}
    */
    isPreloaded() {
        for (let i = 0; i < this.uiElements.length; i++) {
            if (!this.uiElements[i].isPreloaded()) return false;
        }
        return true;
    }

    _onUIElementPreloaded() {
        for (let i = 0; i < this.uiElements.length; i++) {
            if (!this.uiElements[i].isPreloaded()) return;
        }

        this._sendOnPreloadedCallback();
    }
}

/**
A screen that waits for the defined duration while presenting a message.
Fancy animation(s) can be shown using CSS.

@class ScreenWait
@augments Screen
*/
class ScreenWait extends Screen {

    /**
    @param {string} [className] CSS class
    @param {number} [time=2] The time to wait in seconds
    @param {string} [html="Please wait..."] The HTML content to be presented.
    */
    constructor(className, time, html) {
        super(className);

        this.time = !isNaN(time) ? Math.abs(time) * 1000 : 2;
        this.html = typeof(html) === "string" ? html : "Please wait...";

        this.timeoutHandle = null;
        this.readyCallback = null;

        TheFragebogen.logger.debug(this.constructor.name, "Set: time as " + this.time + " and html as " + this.html);
    }

    createUI() {
        this.node = document.createElement("div");
        this.node.innerHTML = this.html;
        this.applyCSS();

        return this.node;
    }

    _startTimer() {
        TheFragebogen.logger.info(this.constructor.name + "._startTimer()", "New screen will be displayed in " + this.time + "ms.");
        this.timeoutHandle = setTimeout(() => this._onWaitTimeReached(), this.time);
    }

    /**
    Starts the timer.
    */
    start() {
        this._startTimer();
    }

    _onWaitTimeReached() {
        this._sendPaginateCallback();

    }
    releaseUI() {
        super.releaseUI();
        clearTimeout(this.timeoutHandle);
        this.timeoutHandle = null;
    }
}

/**
A UIElement that shows non-interactive UI, i.e., plain HTML.
Provided HTML is encapsulated into a div and div.className is set.

@class UIElementHTML
@augments UIElement

*/
class UIElementHTML extends UIElement {
    /**
    @param {string} [className] CSS class
    @param {string} html HTML
    */
    constructor(className, html) {
        super(className);

        this.html = html;
    }

    createUI() {
        this.node = document.createElement("div");
        this.node.innerHTML = this.html;
        this.uiCreated = true;

        this.applyCSS();

        return this.node;
    }
}

/**
A UIElement that has an interactive UI and thus might not be ready in the beginning but requiring user interaction before its goal is fulfilled.

@abstract
@class UIElementInteractive
@augments UIElement
*/
class UIElementInteractive extends UIElement {

    /**
    @param {string} [className] CSS class
    */
    constructor(className) {
        super(className);
        this.enabled = false;
        this.onReadyStateChanged = null;
    }

    setOnReadyStateChangedCallback(onReadyStateChanged) {
        if (onReadyStateChanged instanceof Function) {
            TheFragebogen.logger.debug(this.constructor.name + ".setOnReadyStateChangedCallback()", "called");
            this.onReadyStateChanged = onReadyStateChanged;
        } else {
            this.onReadyStateChanged = null;
        }
    }

    _sendReadyStateChanged() {
        if (this.onReadyStateChanged instanceof Function) {
            TheFragebogen.logger.debug(this.constructor.name + "._sendReadyStateChanged()", "called");
            this.onReadyStateChanged(this);
        }
    }

    /**
    Updates the UI to inform to reflect that this element is _yet_ not ready.
    @abstract
    */
    markRequired() {
        TheFragebogen.logger.debug(this.constructor.name + ".markRequired()", "This method should be overridden.");
    }
}

/**
A QuestionnaireItem is an abstract UIElementInteractive that consists of a question and presents a scale.
The answer on the scale is stored.

NOTE: An QuestionnaireItem that is not yet answered but required, will be marked on check with the CSS class: `className + "Required"`.

DEVERLOPER: Subclasses need to override `_createAnswerNode()`.

@abstract
@class QuestionnaireItem
@augments UIElement
@augments UIElementInteractive
*/
class QuestionnaireItem extends UIElementInteractive {

    /**
    @param {string} [className] CSS class
    @param {string} question question
    @param {boolean} [required=false] Is this QuestionnaireItem required to be answered?
    */
    constructor(className, question, required) {
        super(className);

        this.question = question;
        this.required = required;
        this.answerLog = []; //will store [[Date, answer]...]

        TheFragebogen.logger.debug(this.constructor.name + "()", "Set: className as " + this.className + ", question as " + this.question + " and required as " + this.required);
    }

    /**
    Returns the question.
    @returns {string} The question.
    */
    getQuestion() {
        return this.question;
    }

    /**
    Returns the answer (most recent set).
    @returns {object} The answer.
    */
    getAnswer() {
        if (this.answerLog.length === 0) {
            return null;
        }
        return this.answerLog[this.answerLog.length - 1][1];
    }

    /**
    Returns a copy of the changelog of answers (as generated by `this.setAnswer()`).
    @returns {array<Date, object>} The changelog of answers.
    */
    getAnswerChangelog() {
        return this.answerLog.slice();
    }

    /**
    Sets the answer and adds it to this.answerLog.
    @param {object} answer The answer to be set.
    @returns {boolean} Success or failure.
    */
    setAnswer(answer) {
        this.answerLog.push([new Date(), answer]);
        this._sendReadyStateChanged();
        return true;
    }

    /**
    Is this QuestionnaireItem answered?
    @returns {boolean}
    */
    isAnswered() {
        return this.answerLog.length > 0 && this.answerLog[this.answerLog.length - 1][1] !== null;
    }

    /**
    Returns the list of predefined options.
    @abstract
    @returns {array} undefined by default.
    */
    getAnswerOptions() {
        return undefined;
    }

    /**
    Adjust the UI if the answer was changed using `setAnswer()`.
    @abstract
    */
    applyAnswerToUI() {
        TheFragebogen.logger.debug(this.constructor.name + ".applyAnswerToUI()", "This method might need to be overridden.");
    }

    /**
    Is this QuestionnaireItem ready, i.e., answered if required?
    @returns {boolean}
    */
    isReady() {
        return this.isRequired() ? this.isAnswered() : true;
    }

    /**
    Is this QuestionnaireItem required to be answered?
    @returns {boolean}
    */
    isRequired() {
        return this.required;
    }

    createUI() {
        this.uiCreated = true;

        this.node = document.createElement("div");
        this.applyCSS();

        this.node.appendChild(this._createQuestionNode());
        this.node.appendChild(this._createAnswerNode());

        this.applyAnswerToUI();

        return this.node;
    }

    /**
    Create the UI showing the question.
    @returns {HTMLElement} The div containing the question.
    */
    _createQuestionNode() {
        const questionNode = document.createElement("div");
        questionNode.innerHTML = this.question + (this.required ? "*" : "");
        return questionNode;
    }

    /**
    Create the UI showing the scale.
    @abstract
    @returns {HTMLElement} The HTML container with the scale.
    */
    _createAnswerNode() {
        TheFragebogen.logger.warn(this.constructor.name + "._createAnswerNode()", "This method might need to be overridden.");
    }

    releaseUI() {
        super.releaseUI();
    }

    /**
    Mark this element as required if it was not answered (className + "Required").
    Is called by the Screen if necessary.
    */
    markRequired() {
        if (this.node === null) {
            return;
        }

        const classNameRequired = (this.className !== undefined ? this.className : "") + "Required";
        if (!this.isReady()) {
            this.node.classList.add(classNameRequired);
        } else {
            this.node.classList.remove(classNameRequired);
        }
    }
}

/**
Base class of Screens that handle data export.
Displays a HTML message.

@abstract
@class ScreenWaitData
@augments Screen
@augments ScreenWait
*/
class ScreenWaitData extends ScreenWait {

    /**
    @param {string} [className=""] CSS class
    @param {number} time Time to wait in seconds
    @param {string} message The message to display (HTML)
    @param {boolean} [includeAnswerChangelog=false] Should the the changelog of the answer be reported?
    */
    constructor(className, time, message, includeAnswerChangelog) {
        super(className, time, message);

        this.data = null;
        this.includeAnswerChangelog = includeAnswerChangelog;

        this.getDataCallback = null;
    }

    setGetDataCallback(getDataCallback) {
        if (getDataCallback instanceof Function) {
            TheFragebogen.logger.debug(this.constructor.name + ".setGetDataCallback()", "called");
            this.getDataCallback = getDataCallback;
            return true;
        }
        return false;
    }

    _sendGetDataCallback() {
        if (this.getDataCallback instanceof Function) {
            TheFragebogen.logger.debug(this.constructor.name + "._sendGetDataCallback()", "called");
            this.data = this.getDataCallback(this.includeAnswerChangelog);
        }
    }
}

/**
QuestionnaireItems that have a predefined set of potential answers.

@abstract
@class QuestionnaireItemDefined
@augments UIElement
@augments UIElementInteractive
@augments QuestionnaireItem
*/
class QuestionnaireItemDefined extends QuestionnaireItem {

    /**
    @param {string} [className] CSS class
    @param {string} question
    @param {boolean} [required=false]
    @param {array} optionList Possible options.
    */
    constructor(className, question, required, optionList) {
        super(className, question, required);

        if (!(optionList instanceof Array)) {
            TheFragebogen.logger.error(this.constructor.name + "()", "optionList needs to be an Array.");
        }
        this.optionList = optionList;
        this.input = [];

        TheFragebogen.logger.debug(this.constructor.name + "()", "Set: optionList as " + this.optionList);
    }

    getAnswerOptions() {
        return this.optionList;
    }

    releaseUI() {
        super.releaseUI();

        this.input = [];
    }
}

/**
A QuestionnaireItem that has a predefined set of answer and multiple of these can be selected.
A group of checkboxes is used.
@class QuestionnaireItemDefinedMulti
@augments UIElement
@augments UIElementInteractive
@augments QuestionnaireItem
@augments QuestionnaireItemDefined
*/
class QuestionnaireItemDefinedMulti extends QuestionnaireItemDefined {

/**
@param {string} [className] CSS class
@param {string} question
@param {boolean} [required=false]
@param {array} optionList
*/
constructor(className, question, required, optionList) {
    super(className, question, required, optionList);

    this.identifier = Math.random(); //Part of the identifier for the label + checkbox relation.
}

_createAnswerNode() {
    const answerNode = document.createElement("div");

    for (let i = 0; i < this.optionList.length; i++) {
        this.input[i] = document.createElement("input");
        this.input[i].type = "checkbox";
        this.input[i].id = this.identifier + i;
        this.input[i].name = this.identifier;
        this.input[i].value = this.optionList[i];

        this.input[i].addEventListener("change", (event) => this._handleChange(event));

        const label = document.createElement("label");
        label.setAttribute("for", this.identifier + i);
        label.innerHTML = this.optionList[i];

        answerNode.appendChild(this.input[i]);
        answerNode.appendChild(label);
    }

return answerNode;
}

_handleChange(event) {
    let selectedOptions = this._getAnswer();
    const currentIndex = selectedOptions.indexOf(event.target.value);

    if (event.target.checked && currentIndex === -1) {
        selectedOptions.push(event.target.value);
    }
    if (!event.target.checked) {
        selectedOptions.splice(currentIndex, 1);
    }

    this.setAnswer(selectedOptions.sort());
}

applyAnswerToUI() {
    if (!this.isUIcreated()) {
        return;
    }

    const selectedOptionList = this._getAnswer();
    for (let i = 0; i < this.input.length; i++) {
        this.input[i].checked = selectedOptionList.indexOf(this.optionList[i]) !== -1;
    }
}

getAnswer() {
    return super.getAnswer();
}

_getAnswer() {
    return this.getAnswer() || [];
}

isAnswered() {
    return this._getAnswer().length > 0;
}

releaseUI() {
    super.releaseUI();

    this.identifier = null;
}
}


/**
A QuestionnaireItem for one line text input.
This item uses a HTML input field.

@class QuestionnaireItemText
@augments UIElement
@augments UIElementInteractive
@augments QuestionnaireItem
*/
class QuestionnaireItemText extends QuestionnaireItem {

    /**
    @param {string} [className] CSS class
    @param {string} question
    @param {boolean} [required=false]
    */
    constructor(className, question, required) {
        super(className, question, required);

        this.input = null;
    }

    _createAnswerNode() {
        const answerNode = document.createElement("div");

        this.input = document.createElement("input");
        this.input.addEventListener("change", (event) => this.setAnswer(this.input.value === "" ? null : this.input.value));

        answerNode.appendChild(this.input);

        return answerNode;
    }

    applyAnswerToUI() {
        if (!this.isUIcreated()) {
            return;
        }

        if (this.isAnswered()) {
            this.input.value = this.getAnswer();
        }
    }

    releaseUI() {
        super.releaseUI();

        this.input = null;
    }
}

/**
This QuestionnaireItem connects to a Websocket server and may
a) send a message (ignore incoming messages),
b) wait until a certain message is received, or
c) a) and b).

Notes:
* This QuestionnaireItem is _always_ required.
* Starts connecting on setting `QuestionnaireItemWaitWebsocket.setEnabled(true)`.
* Automatically tries to reconnect on connection failure: message resend on every reconnect.
  IMPORTANT: Please note that this approach is brute force and at the moment ignores _permanent failures_ (HTTP: 404) are not handled.
* After reaching timeout, this element sets itself to ready=true.


Uses CSS classes:
* this.className (Initial before enabling)
* this.className + "Connecting"
* this.className + "Connected"
* this.className + "Reconnecting"
* this.className + "Ready" (required message received)
* NOT this.className + "Required" via `Questionnaire.markRequired()`

@class QuestionnaireItemWaitWebsocket
@augments UIElement
@augments UIElementInteractive
@augments QuestionnaireItem
*/
class QuestionnaireItemWaitWebsocket extends QuestionnaireItem {

    /**
    @param {string} [className] CSS class

    @param {string} url The websocket URL, eg., ws://localhost:8080/someLocation.
    @param {string} [messageReceive=undefined] The message to be waiting for. `undefined`: don't wait.
    @param {string} [messageSend=undefined] The message to be sent. `undefined`: don't send anything.
    @param {number} [reconnectAttempts=-1] Number of attempts to reconnect; negative number: forever.
    @param {number} [timeout=0] Timeout in seconds.
    */
    constructor(className, url, messageSend, messageReceive, reconnectAttempts, timeout) {
        super(className, "", true);

        this.url = url;
        this.messageSend = messageSend;
        this.messageReceive = messageReceive;

        if (this.messageSend === undefined && this.messageReceive === undefined) {
            TheFragebogen.logger.error("QuestionnaireItemWaitWebsocket()", "messageSend and messageReceive are undefined; this component will not do anything.");
        }

        this.reconnectAttempts = !isNaN(reconnectAttempts) ? reconnectAttempts : -1;
        this.timeout = !isNaN(timeout) ? Math.abs(timeout) * 1000 : 0;

        this.websocketConnection = null;
        this.connectionFailures = 0;

        TheFragebogen.logger.warn("QuestionnaireItemWaitWebsocket()", "Set: url as " + this.url + ", messageSend as" + this.messageSend + ", messageReceive as " + this.messageReceive + "and timeout as " + this.timeout);
    }

    createUI() {
        this.node = document.createElement("div");
        this.uiCreated = true;

        this.applyCSS();
        return this.node;
    }

    setEnabled(enabled) {
        super.setEnabled(enabled);

        if (this.isEnabled()) { //Let's connect (and start timer)!
            this._handleConnect();

            if (this.timeout !== 0) {
                this.timeoutHandle = setTimeout(() => this._onTimeout(), this.timeout);
            }
        }
    }

    _handleConnect() {
        if (this.websocketConnection === null) {
            this.websocketConnection = new WebSocket(this.url);

            this.applyCSS("Connecting");

            this.websocketConnection.addEventListener("open", () => this._onConnected());
            this.websocketConnection.addEventListener("message", (event) => this._onMessage(event));
            this.websocketConnection.addEventListener("error", (event) => this._onWebsocketError(event));
            this.websocketConnection.addEventListener("close", (event) => this._onWebsocketClose(event));
        }
    }

    _onConnected() {
        this.applyCSS("Connected");

        if (this.messageSend === undefined) {
            TheFragebogen.logger.info(this.constructor.name + ".connection._onConnected()", "Connection opened.");
        } else {
            this.websocketConnection.send(this.messageSend);
            TheFragebogen.logger.info(this.constructor.name + ".connection._onConnected()", "Connection opened and message <<" + this.messageSend + ">> delivered.");
        }

        if (this.messageReceive === undefined) {
            TheFragebogen.logger.info(this.constructor.name + ".connection._onConnected()", "Connection opened.");
            this.setAnswer(new Date().toString());
            this.applyCSS("Ready");

            this._sendReadyStateChanged();
        }
    }

    _onMessage(event) {
        if (event.data && event.data !== this.messageReceive) {
            TheFragebogen.logger.warn(this.constructor.name + ".connection._onMessage()", "Received unknown message: <<" + event.data + ">>; waiting for <<" + this.messageReceive + ">>");
            return;
        }

        TheFragebogen.logger.info(this.constructor.name + ".connection._onMessage()", "Received correct message.");
        this.setAnswer(new Date().toString());
        this.applyCSS("Ready");

        this._sendReadyStateChanged();
    }

    _onWebsocketError(error) {
        this.applyCSS("Reconnecting");
        TheFragebogen.logger.warn(this.constructor.name + ".connection._onWebsocketError()", error);
        //Reconnect handled by onclose
    }

    _onWebsocketClose() {
        TheFragebogen.logger.warn(this.constructor.name + ".connection._onWebsocketClose()", "Connection closed.");

        if (this.isReady()) {
            return;
        }

        //Retry?
        if (this.reconnectAttempts === -1 || this.connectionFailures < this.reconnectAttempts) {
            TheFragebogen.logger.warn(this.constructor.name + ".connection._onWebsocketClose.setTimeout._anonymousFunction()", "Trying to reconnect...");

            this.websocketConnection = null;
            this._handleConnect();

            return;
        }

        //Failed permanently: That's bad...
        TheFragebogen.logger.error(this.constructor.name + ".connection._onWebsocketClose()", "Maximal number of attempts reached. QuestionnaireItemWaitWebsocket will not try to reconnect again!");
        this.ready = true;
        this._sendReadyStateChanged();
    }

    _onTimeout() {
        this._sendReadyStateChanged();

        TheFragebogen.logger.warn(this.constructor.name + "._onTimeout()", "Waiting got timeout after " + (!this.connectionFailures ? (this.timeout + "ms.") : (this.connectionFailures + " attempt(s).")));
    }

    markRequired() {
        //This elements shows its status and is always required.
    }

    releaseUI() {
        super.releaseUI();

        clearTimeout(this.timeoutHandle);
        this.timeoutHandle = null;

        if (this.websocketConnection !== null && (this.websocketConnection.readyState == WebSocket.CONNECTING || this.websocketConnection.readyState == WebSocket.OPEN)) {
            this.websocketConnection.onclose = () => TheFragebogen.logger.info(this.constructor.name + ".connection._releaseUI()", "Connection closed.");
            this.websocketConnection.close();
        }
        this.websocketConnection = null;
    }
}

/**
A screen that downloads the currently stored data of the questionnaire in CSV format as a file.
A message is presented while uploading.
Default timeout: 300s; should not be relevant.
@class ScreenWaitDataDownload
@augments Screen
@augments ScreenWait
@augments ScreenWaitData
*/
class ScreenWaitDataDownload extends ScreenWaitData {

/**
@param {string} [className] CSS class
@param {string} [message="Downloading data"] Message to be displayed.
@param {string} [filename="TheFragebogen.csv"] Name of the file to be downloaded
@param {boolean} [includeAnswerChangelog=false] Should the the changelog of the answer be reported?
*/
constructor(className, message, filename, includeAnswerChangelog) {
    super(className, 300, typeof(message) === "string" ? message : "Downloading data", includeAnswerChangelog);

    this.filename = (typeof(filename) === "string" ? filename : "TheFragebogen.csv");

    TheFragebogen.logger.debug(this.constructor.name + "()", "Set: filename as " + this.filename);
}

createUI() {
    this.node = document.createElement("div");
    this.applyCSS();

    const span = document.createElement("span");
    span.innerHTML = this.html;
    this.node.appendChild(span);

    return this.node;
}

/**
On start(), the screenController.requestDataCSV() is called with this.callbackDownload() as callback.
ScreenController needs to set the callback accordingly.
*/
start() {
    this._sendGetDataCallback();
    this.callbackDownload(this.data);
}

/**
Callback to download data.
@param {string} data
*/
callbackDownload(data) {
    TheFragebogen.logger.info(this.constructor.name + ".callbackDownload()", data);
    downloadData(this.filename, data);
    this._sendPaginateCallback();
}
}

/**
A screen that uploads the currently stored data of the questionnaire in CSV format to a webserver via AJAX (HTTP POST).
A message is presented while uploading.
Default timeout: 4s.

USER: Be aware of Cross-site origin policy: http://en.wikipedia.org/wiki/Cross-origin_resource_sharing
The web server must be configured accordingly if upload URL is different than the URL the questionnaire was loaded from.

@class ScreenWaitDataUpload
@augments Screen
@augments ScreenWait
@augments ScreenWaitData
*/
class ScreenWaitDataUpload extends ScreenWaitData {

    /**
     *
     * ScreenWaitDataUpload(undefined, "/TheFragebogen", 4, "Uploading data. Please wait ...", "data", "Upload failed. Data will ve downloaded to local computer now.", true, false)
    @param {string} [className] CSS class
    @param {string} [url]
    @param {number} [timeout=4] timeout in seconds
    @param {string} [message="UHere you can get to the map:<br><a href='https://vm010.qu.tu-berlin.de/map/'>-->"]
    @param {string} [httpParamaterName="data"]
    @param {string} [failMessage="Upload failed. Data will be downloaded to local computer now."]
    @param {boolean} [nextScreenOnFail=true] Continue to next screen if upload failed.
    @param {boolean} [includeAnswerChangelog=false] 
    */
    constructor(className, url, timeout, message, httpParameterName, failMessage, nextScreenOnFail, includeAnswerChangelog) {
        super(className, !isNaN(timeout) ? Math.abs(timeout) : 4, typeof(message) === "string" ? message : "Uploading data. Please wait...", includeAnswerChangelog);

        this.failMessage = (typeof(failMessage) === "string" ? failMessage : "Upload failed. Data will be downloaded to local computer now.");
        this.httpParameterName = (typeof(httpParameterName) === "string" ? httpParameterName : "data");
        this.nextScreenOnFail = (typeof(nextScreenOnFail) === "boolean") ? nextScreenOnFail : true;

        this.url = url;
        this.request = null;
        this.retryCount = 0;
        this.data = null;
        this.retry = 0;

        TheFragebogen.logger.debug(this.constructor.name + "()", "Set: httpParameterName as " + this.httpParameterName);
    }

    createUI() {
        this.node = document.createElement("div");
        this.applyCSS();

        const span = document.createElement("span");
        span.innerHTML = this.html;
        this.node.appendChild(span);

        if (this.paginateUI != null) {
            this.paginateUI.setPaginateCallback(() => this._sendPaginateCallback());
            this.node.appendChild(this.paginateUI.createUI());
        }

        return this.node;
    }

    /**
    On start(), the screenController.requestDataCSV() is called with this.callbackUpload() as callback.
    */
    start() {
        this.retryCount = 0;

        this._sendGetDataCallback();
        this.callbackUpload(this.data);
    }

    /**
    Callback to upload data.
    @param {string} data
    */
    callbackUpload(data) {
        TheFragebogen.logger.info(this.constructor.name + ".callbackUpload()", "Starting upload to " + this.url);

        this.retry = null;
        this.retryCount++;
        this.data = data;

        this.request = new XMLHttpRequest();
        this.request.open("POST", this.url, true);
        this.request.timeout = this.time;

        this.request.addEventListener("timeout", () => this._onTimeout());
        this.request.addEventListener("load", () => this._onLoad());
        this.request.addEventListener("error", (event) => this._onError(event));

        this.request.send(this.httpParameterName + "=" + data);
    }

    /**
    Callback if upload was successful; screen is then ready to continue.
    */
    _onLoad() {
        if (this.request.readyState === 4 && this.request.status === 200) {
            TheFragebogen.logger.info(this.constructor.name + ".callbackUpload()", "Successful.");
            if (this.request.responseText !== "") {
                TheFragebogen.logger.info(this.constructor.name + "._onLoad()", this.request.responseText);
            }

            this._sendPaginateCallback();
        } else {
            TheFragebogen.logger.error(this.constructor.name + "._onLoad()", "Request to " + this.url + " failed with status code " + this.request.status);
            this.retryCount = 4;
            this._onError();
        }

        this.request = null;
    }

    /**
    Callback if upload failed and schedules a retry.
    */
    _onError(event) {
        const span = document.createElement("span");
        span.innerHTML = "" + "Upload failed. With request status " + this.request.status + " Retrying in 5 seconds.";
        this.node.appendChild(span);
        this.retry = setTimeout(() => this.callbackUpload(), 5000, this.data);

        TheFragebogen.logger.error(this.constructor.name + ".callbackUpload()", "Upload failed with HTTP code: " + this.request.status + ". Retrying in 5 seconds.");
    }

    /**
    Callback if timeout.
    */
    _onTimeout() {
        TheFragebogen.logger.error(this.constructor.name + ".callbackUpload()", "Upload got timeout after " + this.time + "ms.");
        this._onError();
    }

    releaseUI() {
        super.releaseUI();

        if (this.retry !== null) {
            clearTimeout(this.retry);
        }

        if (this.request instanceof XMLHttpRequest) {
            this.request.abort();
        }
        this.request = null;
    }
}

/**
QuestionnaireItems that have a predefined set of answer and one of these can be selected.
A group of radiobuttons is used.

@class QuestionnaireItemDefinedOne
@augments UIElement
@augments UIElementInteractive
@augments QuestionnaireItem
@augments QuestionnaireItemDefined
*/
class QuestionnaireItemDefinedOne extends QuestionnaireItemDefined {

    /**
    @param {string} [className] CSS class
    @param {string} questions
    @param {boolean} [required=false]
    @param {array} optionList
    */
    constructor(className, question, required, optionList) {
        super(className, question, required, optionList);

        this.identifier = Math.random(); //Part of the identifier for the label + radiobutton relation.
    }

    _createAnswerNode() {
        const tableRowLabel = document.createElement('tr');
        const tableRowRadio = document.createElement('tr');

        for (let i = 0; i < this.optionList.length; i++) {
            this.input[i] = document.createElement("input");
            this.input[i].value = i;
            this.input[i].id = this.identifier + i;
            this.input[i].name = this.identifier;
            this.input[i].type = "radio";

            if (this.getAnswer() === this.optionList[i]) {
                this.input[i].checked = true;
            }

            this.input[i].addEventListener("change", (event) => this.setAnswer(this.optionList[event.target.value]));

            const label = document.createElement("label");
            label.setAttribute("for", this.identifier + i);
            label.innerHTML = this.optionList[i];

            const tdLabel = document.createElement('td');
            tdLabel.appendChild(label);
            tableRowLabel.appendChild(tdLabel);

            const tdRadio = document.createElement('td');
            tdRadio.appendChild(this.input[i]);
            tableRowRadio.appendChild(tdRadio);
        }

        const tableBody = document.createElement('tbody');
        tableBody.appendChild(tableRowLabel);
        tableBody.appendChild(tableRowRadio);

        const table = document.createElement('table');
        table.style.display = "inline"; //CSS
        table.appendChild(tableBody);

        return table;
    }

    applyAnswerToUI() {
        if (!this.isUIcreated()) {
            return;
        }

        if (this.getAnswer() === null) {
            this.input.map((input) => input.checked = false);
            return;
        }

        const selectedOption = this.optionList.indexOf(this.getAnswer());
        if (selectedOption === -1) {
            TheFragebogen.logger.warn(this.constructor.name, "applyAnswerToUI(): option unknown; cannot restore to UI. " + this.getAnswer());
            return;
        }

        this.input[optionList].checked = true;
    }

    releaseUI() {
        super.releaseUI();

        this.identifier = null;
    }
}

function shuffle(array) {
  let currentIndex = array.length,  randomIndex;

  // While there remain elements to shuffle.
  while (currentIndex != 0) {

    // Pick a remaining element.
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;

    // And swap it with the current element.
    [array[currentIndex], array[randomIndex]] = [
      array[randomIndex], array[currentIndex]];
  }

  return array;
}

</script>
        vbnm
        <script>
        var screensFirstWTA = [];
        var screensShuffleWTA = [];
        var screensShuffleWTP = [];
        var screens = [];
        var screensAll = [];

        var screen1 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Daten zu verkaufen</h1>"),
            new UIElementHTML(undefined, "<h3 align=justify style=font-weight:normal> Im Folgenden werden Ihnen mehrer Fragen zu Ihrer Bereitschaft Ihre Daten zu verkaufen gestellt. Bitte antworten Sie so wahrheitsgetreu wie möglich. </h3>"), //screen 1 soll nicht in der Randomisierung mit einbegriffen sein - done
            new UIElementHTML(undefined, "<h3 align=justify style=font-weight:normal> Stellen Sie sich vor, es kommt zu einer Monopolstellung auf dem deutschen Internetprovider Markt. Alle bisherigen Anbieter wurden von der “Connect-AG” aufgekauft, alle bestehenden Verträge bleiben jedoch bis auf eine Änderung gleich: Von nun an werden ihre Standortdaten für Statistik- und Marketingzwecke erhoben und ggf. auch weiterverkauft. Da das Bundeskartellamt dem Kauf aller Unternehmen durch die Connect-AG jedoch nur unter Auflagen zugestimmt hat, dürfen sie entscheiden, welche Daten erhoben werden und bekommen für diese sogar Geld. Das Unternehmen hat daraufhin mehrere Optionen und Modelle entwickelt, die auf den folgenden Seiten abgebildet sind. Bitte wählen Sie auf jeder Seite eine der vier Optionen aus. Damit wird angegeben, welche der folgenden Datentypen Sie an das Unternehmen für den jeweiligen Betrag monatlich verkaufen würden?</h3>"), //Scenario Beschreibung und Aufgabenbeschriebung fehlt hier noch! 
            new QuestionnaireItemDefinedOne("questionnaireItem", "Sind Sie generell bereit Ihre Daten an Unternehmen zu verkaufen?.<hr>", true, ["Ja", "Unter bestimmten Vorraussetzungen", "Nein"]),//Categoriccal Question - Optionen untereinander darstellen - es sollen mehrere Optionen anklickbar sein - done 
            new QuestionnaireItemDefinedMulti("questionnaireItem", "Welche der folgenden Datentypen würden Sie verkaufen?<hr>", true, ["Körperliche Betätigung<br>", "Wohnort<br>", "Fortbewegung<br>", "Einkaufen<br>", "Beruf<br>", "Freizeit<br>"]), //Categoriccal Question - Optionen untereinander darstellen - es sollen mehrere Optionen anklickbar sein -done
            );
        screensFirstWTA.push(screen1);

/*
        var screen2 = new ScreenUIElements(
            new QuestionnaireItemDefinedOne("questionnaireItem", "Sind Sie generell bereit Ihre Daten an Unternehmen zu verkaufen?.<hr>", true, ["Ja<br>", "Unter bestimmten Vorraussetzungen<br>", "Nein<br>"]),//Categoriccal Question - Optionen untereinander darstellen - es sollen mehrere Optionen anklickbar sein - done 
            new QuestionnaireItemDefinedMulti("questionnaireItem", "Welche der folgenden Datentypen würden Sie verkaufen?<hr>", true, ["Körperliche Betätigung <br>", "Wohnort<br>", "Fortbewegung<br>", "Einkaufen<br>", "Beruf<br>", "Freizeit<br>"]), //Categoriccal Question - Optionen untereinander darstellen - es sollen mehrere Optionen anklickbar sein -done
            );
        screensFirstWTA.push(screen2);
*/

        var screen3 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Daten zu verkaufen</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würde Sie an das Unternehmen für den angegebenen Betrag monatlich verkaufen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h2>", true, ["<img src='"+ HOST +"/get_image?image=wta_sets/set_1/set_1_option_1.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_1/set_1_option_2.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_1/set_1_option_3.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_1/set_1_option_4.png'>"]),
        );
        screensShuffleWTA.push(screen3);

        var screen4 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Daten zu verkaufen</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal>Welche der folgenden Datentypen würde Sie an das Unternehmen für den angegebenen Betrag monatlich verkaufen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h2>", true, ["<img src='"+ HOST +"/get_image?image=wta_sets/set_2/set_2_option_1.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_2/set_2_option_2.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_2/set_2_option_3.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_2/set_2_option_4.png'>"]),
        );
        screensShuffleWTA.push(screen4);

        var screen5 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Daten zu verkaufen</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal>Welche der folgenden Datentypen würde Sie an das Unternehmen für den angegebenen Betrag monatlich verkaufen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+ HOST +"/get_image?image=wta_sets/set_3/set_3_option_1.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_3/set_3_option_2.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_3/set_3_option_3.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_3/set_3_option_4.png'>"]),
        );
        screensShuffleWTA.push(screen5);

        var screen6 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Daten zu verkaufen</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würde Sie an das Unternehmen für den angegebenen Betrag monatlich verkaufen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+ HOST +"/get_image?image=wta_sets/set_4/set_4_option_1.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_4/set_4_option_2.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_4/set_4_option_3.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_4/set_4_option_4.png'>"]),
        );
        screensShuffleWTA.push(screen6);

        var screen7 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Daten zu verkaufen</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würde Sie an das Unternehmen für den angegebenen Betrag monatlich verkaufen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+ HOST +"/get_image?image=wta_sets/set_5/set_5_option_1.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_5/set_5_option_2.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_5/set_5_option_3.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_5/set_5_option_4.png'>"]),
        );
        screensShuffleWTA.push(screen7);

        var screen8 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Daten zu verkaufen</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würde Sie an das Unternehmen für den angegebenen Betrag monatlich verkaufen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+ HOST +"/get_image?image=wta_sets/set_6/set_6_option_1.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_6/set_6_option_2.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_6/set_6_option_3.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_6/set_6_option_4.png'>"]),
        );
        screensShuffleWTA.push(screen8);

        var screen9 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Daten zu verkaufen</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würde Sie an das Unternehmen für den angegebenen Betrag monatlich verkaufen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+ HOST +"/get_image?image=wta_sets/set_7/set_7_option_1.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_7/set_7_option_2.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_7/set_7_option_3.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_7/set_7_option_4.png'>"]),
        );
        screensShuffleWTA.push(screen9);

        var screen10 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Daten zu verkaufen</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würde Sie an das Unternehmen für den angegebenen Betrag monatlich verkaufen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+ HOST +"/get_image?image=wta_sets/set_8/set_8_option_1.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_8/set_8_option_2.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_8/set_8_option_3.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_8/set_8_option_4.png'>"]),
        );
        screensShuffleWTA.push(screen10);

        var screen11 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Daten zu verkaufen</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem","<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würde Sie an das Unternehmen für den angegebenen Betrag monatlich verkaufen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+ HOST +"/get_image?image=wta_sets/set_9/set_9_option_1.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_9/set_9_option_2.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_9/set_9_option_3.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_9/set_9_option_4.png'>"]),
        );
        screensShuffleWTA.push(screen11);

        var screen12 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Daten zu verkaufen</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würde Sie an das Unternehmen für den angegebenen Betrag monatlich verkaufen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+ HOST +"/get_image?image=wta_sets/set_10/set_10_option_1.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_10/set_10_option_2.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_10/set_10_option_3.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_10/set_10_option_4.png'>"]),
        );
        screensShuffleWTA.push(screen12);

        var screen13 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Daten zu verkaufen</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem","<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würde Sie an das Unternehmen für den angegebenen Betrag monatlich verkaufen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+ HOST +"/get_image?image=wta_sets/set_11/set_11_option_1.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_11/set_11_option_2.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_11/set_11_option_3.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_11/set_11_option_4.png'>"]),
        );
        screensShuffleWTA.push(screen13);

        var screen14 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Daten zu verkaufen</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem","<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würde Sie an das Unternehmen für den angegebenen Betrag monatlich verkaufen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+ HOST +"/get_image?image=wta_sets/set_12/set_12_option_1.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_12/set_12_option_2.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_12/set_12_option_3.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_12/set_12_option_4.png'>"]),
        );
        screensShuffleWTA.push(screen14);

        var screen15 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Daten zu verkaufen</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem","<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würde Sie an das Unternehmen für den angegebenen Betrag monatlich verkaufen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+ HOST +"/get_image?image=wta_sets/set_13/set_13_option_1.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_13/set_13_option_2.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_13/set_13_option_3.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_13/set_13_option_4.png'>"]),
        );
        screensShuffleWTA.push(screen15);

        var screen16 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Daten zu verkaufen</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würde Sie an das Unternehmen für den angegebenen Betrag monatlich verkaufen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+ HOST +"/get_image?image=wta_sets/set_14/set_14_option_1.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_14/set_14_option_2.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_14/set_14_option_3.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_14/set_14_option_4.png'>"]),
        );
        screensShuffleWTA.push(screen16);

        var screen17 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Daten zu verkaufen</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würde Sie an das Unternehmen für den angegebenen Betrag monatlich verkaufen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+ HOST +"/get_image?image=wta_sets/set_15/set_15_option_1.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_15/set_15_option_2.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_15/set_15_option_3.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_15/set_15_option_4.png'>"]),
        );
        screensShuffleWTA.push(screen17);

        var screen18 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Daten zu verkaufen</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würde Sie an das Unternehmen für den angegebenen Betrag monatlich verkaufen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+ HOST +"/get_image?image=wta_sets/set_16/set_16_option_1.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_16/set_16_option_2.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_16/set_16_option_3.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_16/set_16_option_4.png'>"]),
        );
        screensShuffleWTA.push(screen18);

        var screen19 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Daten zu verkaufen</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würde Sie an das Unternehmen für den angegebenen Betrag monatlich verkaufen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+ HOST +"/get_image?image=wta_sets/set_17/set_17_option_1.png'>", "<img src='" + HOST +"/get_image?image=wta_sets/set_17/set_17_option_2.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_17/set_17_option_3.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_17/set_17_option_4.png'>"]),
        );
        screensShuffleWTA.push(screen19);

        var screen191 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Daten zu verkaufen</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem","<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würde Sie an das Unternehmen für den angegebenen Betrag monatlich verkaufen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+ HOST +"/get_image?image=wta_sets/set_18/set_18_option_1.png'>", "<img src='" +  HOST +"/get_image?image=wta_sets/set_18/set_18_option_2.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_18/set_18_option_3.png'>", "<img src='" + HOST + "/get_image?image=wta_sets/set_18/set_18_option_4.png'>"]),
        );
        screensShuffleWTA.push(screen191);

        shuffle(screensShuffleWTA);

        // WTP Questions starting here

        var screen20 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft für den Schutz Ihrer Daten zu zahlen</h1>"), //screen 20 soll nicht in der Randomisierung mit einbegriffen sein - done
            new UIElementHTML(undefined, "<h3 align=justify style=font-weight:normal> Im Folgenden werden Ihnen mehrere Fragen zu Ihrer Bereitschaft für den Schutz Ihrer Daten zu bezahlen gestellt. Bitte antworten Sie so wahrheitsgetreu wie möglich. </h3>"),
            new UIElementHTML(undefined, "<h3 align=justify style=font-weight:normal> Nach langem Streit mit dem Bundeskartellamt wird der Connect-AG auch eine weitere Möglichkeit zur Datenerhebung ihrer Kunden gegeben. Die Connect-AG wird von nun an nicht Sie bezahlen, um Ihre Daten erheben zu dürfen. Stattdessen zahlen alle Kunden einen monatlichen Betrag, um sich dafür gewisse Daten zu schützen, sprich nicht erheben zu lassen. Das Unternehmen hat daraufhin mehrere Optionen und Modelle entwickelt, die auf den folgenden Seiten abgebildet sind. Bitte wählen Sie auf jeder Seite eine der vier Optionen aus. Damit wird angegeben, welche der folgenden Datentypen würden Sie vor dem Unternehmen für den angegebenen Betrag monatlich schützen? </h3>"), //Scenario Beschreibung mit Referenz auf die vorherige Beschreibung, selbes Szenario -  und Aufgabenbeschriebung fehlt hier noch! monatliche Basis 
            new QuestionnaireItemDefinedOne("questionnaireItem", "Sind Sie generell bereit für den Schutz Ihrer Daten zu bezahlen?.<hr>", true, ["Ja", "Unter bestimmten Vorraussetzungen", "Nein"]),
            new QuestionnaireItemDefinedMulti("questionnaireItem", "Für den Schutz welcher der Folgenden Datentypen sind Sie bereit Geld auszugeben?<hr>", true, ["Körperliche Betätigung <br>", "Wohnort<br>", "Fortbewegung<br>", "Einkaufen<br>", "Beruf<br>", "Freizeit<br>"]), //Categoriccal Question - Optionen untereinander darstellen - es sollen mehrere Optionen anklickbar sein - done
            );
        screensShuffleWTA.push(screen20);
/*
        var screen201 = new ScreenUIElements(
            new QuestionnaireItemDefinedOne("questionnaireItem", "Sind Sie generell bereit für den Schutz Ihrer Daten zu bezahlen?.<hr>", true, ["Ja", "Unter bestimmten Vorraussetzungen", "Nein"]),
            new QuestionnaireItemDefinedMulti("questionnaireItem", "Für den Schutz welcher der Folgenden Datentypen sind Sie bereit Geld auszugeben?<hr>", true, ["Körperliche Betätigung <br>", "Wohnort<br>", "Fortbewegung<br>", "Einkaufen<br>", "Beruf<br>", "Freizeit<br>"]), //Categoriccal Question - Optionen untereinander darstellen - es sollen mehrere Optionen anklickbar sein - done
            );
        screensShuffleWTA.push(screen201);
*/

        var screen21 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Geld für den Schutz Ihrer Daten auszugeben</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würden Sie vor dem Unternehmen für den angegebenen Betrag monatlich schützen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+ HOST +"/get_image?image=wtp_sets/set_1/set_1_option_1.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_1/set_1_option_2.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_1/set_1_option_3.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_1/set_1_option_4.png'>"]),
        );
        screensShuffleWTP.push(screen21);

        var screen22 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Geld für den Schutz Ihrer Daten auszugeben</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würden Sie vor dem Unternehmen für den angegebenen Betrag monatlich schützen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+ HOST +"/get_image?image=wtp_sets/set_2/set_2_option_1.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_2/set_2_option_2.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_2/set_2_option_3.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_2/set_2_option_4.png'>"]),
        );
        screensShuffleWTP.push(screen22);

        var screen23 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Geld für den Schutz Ihrer Daten auszugeben</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würden Sie vor dem Unternehmen für den angegebenen Betrag monatlich schützen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+ HOST +"/get_image?image=wtp_sets/set_3/set_3_option_1.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_3/set_3_option_2.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_3/set_3_option_3.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_3/set_3_option_4.png'>"]),
        );
        screensShuffleWTP.push(screen23);

        var screen24 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Geld für den Schutz Ihrer Daten auszugeben</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würden Sie vor dem Unternehmen für den angegebenen Betrag monatlich schützen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+HOST + "/get_image?image=wtp_sets/set_4/set_4_option_1.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_4/set_4_option_2.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_4/set_4_option_3.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_4/set_4_option_4.png'>"]),
        );
        screensShuffleWTP.push(screen24);

        var screen25 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Geld für den Schutz Ihrer Daten auszugeben</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würden Sie vor dem Unternehmen für den angegebenen Betrag monatlich schützen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+HOST + "/get_image?image=wtp_sets/set_5/set_5_option_1.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_5/set_5_option_2.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_5/set_5_option_3.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_5/set_5_option_4.png'>"]),
        );
        screensShuffleWTP.push(screen25);

        var screen26 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Geld für den Schutz Ihrer Daten auszugeben</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würden Sie vor dem Unternehmen für den angegebenen Betrag monatlich schützen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+HOST + "/get_image?image=wtp_sets/set_6/set_6_option_1.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_6/set_6_option_2.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_6/set_6_option_3.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_6/set_6_option_4.png'>"]),
        );
        screensShuffleWTP.push(screen26);

        var screen27 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Geld für den Schutz Ihrer Daten auszugeben</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würden Sie vor dem Unternehmen für den angegebenen Betrag monatlich schützen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+HOST + "/get_image?image=wtp_sets/set_7/set_7_option_1.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_7/set_7_option_2.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_7/set_7_option_3.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_7/set_7_option_4.png'>"]),
        );
        screensShuffleWTP.push(screen27);

        var screen28 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Geld für den Schutz Ihrer Daten auszugeben</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würden Sie vor dem Unternehmen für den angegebenen Betrag monatlich schützen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+HOST + "/get_image?image=wtp_sets/set_8/set_8_option_1.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_8/set_8_option_2.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_8/set_8_option_3.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_8/set_8_option_4.png'>"]),
        );
        screensShuffleWTP.push(screen28);

        var screen29 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Geld für den Schutz Ihrer Daten auszugeben</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würden Sie vor dem Unternehmen für den angegebenen Betrag monatlich schützen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+HOST + "/get_image?image=wtp_sets/set_9/set_9_option_1.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_9/set_9_option_2.png'>", "<img src='" +HOST +  "/get_image?image=wtp_sets/set_9/set_9_option_3.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_9/set_9_option_4.png'>"]),
        );
        screensShuffleWTP.push(screen29);

        var screen30 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Geld für den Schutz Ihrer Daten auszugeben</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würden Sie vor dem Unternehmen für den angegebenen Betrag monatlich schützen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+HOST + "/get_image?image=wtp_sets/set_10/set_10_option_1.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_10/set_10_option_2.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_10/set_10_option_3.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_10/set_10_option_4.png'>"]),
        );
        screensShuffleWTP.push(screen30);

        var screen31 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Geld für den Schutz Ihrer Daten auszugeben</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würden Sie vor dem Unternehmen für den angegebenen Betrag monatlich schützen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+HOST + "/get_image?image=wtp_sets/set_11/set_11_option_1.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_11/set_11_option_2.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_11/set_11_option_3.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_11/set_11_option_4.png'>"]),
        );
        screensShuffleWTP.push(screen31);

        var screen32 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Geld für den Schutz Ihrer Daten auszugeben</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würden Sie vor dem Unternehmen für den angegebenen Betrag monatlich schützen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+HOST + "/get_image?image=wtp_sets/set_12/set_12_option_1.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_12/set_12_option_2.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_12/set_12_option_3.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_12/set_12_option_4.png'>"]),
        );
        screensShuffleWTP.push(screen32);

        var screen33 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Geld für den Schutz Ihrer Daten auszugeben</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würden Sie vor dem Unternehmen für den angegebenen Betrag monatlich schützen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+HOST + "/get_image?image=wtp_sets/set_13/set_13_option_1.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_13/set_13_option_2.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_13/set_13_option_3.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_13/set_13_option_4.png'>"]),
        );
        screensShuffleWTP.push(screen33);

        var screen34 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Geld für den Schutz Ihrer Daten auszugeben</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würden Sie vor dem Unternehmen für den angegebenen Betrag monatlich schützen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+HOST + "/get_image?image=wtp_sets/set_14/set_14_option_1.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_14/set_14_option_2.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_14/set_14_option_3.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_14/set_14_option_4.png'>"]),
        );
        screensShuffleWTP.push(screen34);

        var screen35 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Geld für den Schutz Ihrer Daten auszugeben</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würden Sie vor dem Unternehmen für den angegebenen Betrag monatlich schützen? Bitte wählen Sie eine der vier Optionen, die Ihrer Pärferenz am nächsten kommt.<h3>", true, ["<img src='"+HOST + "/get_image?image=wtp_sets/set_15/set_15_option_1.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_15/set_15_option_2.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_15/set_15_option_3.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_15/set_15_option_4.png'>"]),
        );
        screensShuffleWTP.push(screen35);

        var screen36 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Geld für den Schutz Ihrer Daten auszugeben</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würden Sie vor dem Unternehmen für den angegebenen Betrag monatlich schützen? Bitte wählen Sie eine der vier Optionen, die Ihrer Pärferenz am nächsten kommt.<h3>", true, ["<img src='"+HOST + "/get_image?image=wtp_sets/set_16/set_16_option_1.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_16/set_16_option_2.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_16/set_16_option_3.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_16/set_16_option_4.png'>"]),
        );
        screensShuffleWTP.push(screen36);

        var screen37 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Wert von Daten: Bereitschaft Geld für den Schutz Ihrer Daten auszugeben</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "<h3 align=justify style=font-weight:normal> Welche der folgenden Datentypen würden Sie vor dem Unternehmen für den angegebenen Betrag monatlich schützen? Bitte wählen Sie eine der vier Optionen, die Ihrer Präferenz am nächsten kommt.<h3>", true, ["<img src='"+HOST + "/get_image?image=wtp_sets/set_17/set_17_option_1.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_17/set_17_option_2.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_17/set_17_option_3.png'>", "<img src='" + HOST + "/get_image?image=wtp_sets/set_17/set_17_option_4.png'>"]),
        );
        screensShuffleWTP.push(screen37);

        shuffle(screensShuffleWTP);

        var screen39 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Erwartete Datenverebreitungspraktiken des Unternehmens</h1>"), 
            new QuestionnaireItemDefinedOne("questionnaireItem", "Wie vertrauenswürdig schätzen Sie die Connect-AG ein?<hr>", true, ["Nicht vertrauenswürdig", "Eher nicht vertrauenswürdig", "Weder noch", "Eher vertrauenswürdig", "Vertrauenswürdig"]), //TODO - Hannes: noch Unternehemnsname einfügen je nach Szenariobeschreibung 
            new QuestionnaireItemDefinedOne("questionnaireItem", "Denken Sie, die Connect-AG würde die Daten dennoch nutzen und weiterleiten auch wenn Sie für den Schutz ihrer Daten bezahlen?<hr>", true, ["Nein", "Wahrscheinlich nicht", "Wahrscheinlich schon", "Ja"]), //TODO - Hannes: noch Unternehemnsname einfügen je nach Szenariobeschreibung 
        );
        screens.push(screen39);

        var screen40 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Generelle Einstellung zur Privatsphäre</h1>"),
            new UIElementHTML(undefined, "<h3 align=justify style=font-weight:normal> Im Folgenden werden Ihnen mehrer Fragen zu Ihrer generellen Einstellung zur Privatsphäre gefragt. Bitte antworten Sie so wahrheitsgetreu wie möglich. </h3>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "Unternehmen, die online Informationen einholen, sollten offenlegen, wie die Daten erhoben, verarbeitet und genutzt werden.<hr>", true, ["Stimme ganz <br>und gar nicht zu", "stimme <br>nicht zu", "stimme eher <br>nicht zu", "neutral", "stimme <br>eher zu", "stimme zu", "Stimme ganz <br>und gar zu"]),
            new QuestionnaireItemDefinedOne("questionnaireItem", "Eine gute Online-Datenschutzpolitik für Verbraucher sollte eine klare und deutliche Offenlegung enthalten.<hr>", true, ["Stimme ganz <br>und gar nicht zu", "stimme <br>nicht zu", "stimme eher <br>nicht zu", "neutral", "stimme <br>eher zu", "stimme zu", "Stimme ganz <br>und gar zu"]),
            new QuestionnaireItemDefinedOne("questionnaireItem", "Es ist mir sehr wichtig, dass ich über die Verwendung meiner persönlichen Daten Bescheid weiß.<hr>", true, ["Stimme ganz <br>und gar nicht zu", "stimme <br>nicht zu", "stimme eher <br>nicht zu", "neutral", "stimme <br>eher zu", "stimme zu", "Stimme ganz <br>und gar zu"]),
            //new UIElementHTML(undefined, "<h4><br><br>Datensammlung</h4>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "Normalerweise stört es mich, wenn Online-Unternehmen mich nach persönlichen Daten fragen.<hr>", true, ["Stimme ganz <br>und gar nicht zu", "stimme <br>nicht zu", "stimme eher <br>nicht zu", "neutral", "stimme <br>eher zu", "stimme zu", "Stimme ganz <br>und gar zu"]),
            new QuestionnaireItemDefinedOne("questionnaireItem", "Wenn mich Online-Unternehmen nach persönlichen Informationen fragen, überlege ich manchmal zweimal, bevor ich sie weitergebe.<hr>", true, ["Stimme ganz <br>und gar nicht zu", "stimme <br>nicht zu", "stimme eher <br>nicht zu", "neutral", "stimme <br>eher zu", "stimme zu", "Stimme ganz <br>und gar zu"]),
            new QuestionnaireItemDefinedOne("questionnaireItem", "Es stört mich, dass ich so vielen Online-Unternehmen persönliche Informationen gebe.<hr>", true, ["Stimme ganz <br>und gar nicht zu", "stimme <br>nicht zu", "stimme eher <br>nicht zu", "neutral", "stimme <br>eher zu", "stimme zu", "Stimme ganz <br>und gar zu"]),
            new QuestionnaireItemDefinedOne("questionnaireItem", "Ich bin besorgt, dass Online-Unternehmen zu viele persönliche Daten über mich sammeln.<hr>", true, ["Stimme ganz <br>und gar nicht zu", "stimme <br>nicht zu", "stimme eher <br>nicht zu", "neutral", "stimme <br>eher zu", "stimme zu", "Stimme ganz <br>und gar zu"]),
            //new UIElementHTML(undefined, "<h4><br><br>Kontrolle</h4>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "Der Online-Datenschutz der Verbraucher ist eigentlich eine das Recht der Verbraucher Kontrolle auszuüben, auf welche Art und Weise ihre Daten gesammelt, verwendet und weitergegeben werden.<hr>", true, ["Stimme ganz <br>und gar nicht zu", "stimme <br>nicht zu", "stimme eher <br>nicht zu", "neutral", "stimme <br>eher zu", "stimme zu", "Stimme ganz <br>und gar zu"]),
            new QuestionnaireItemDefinedOne("questionnaireItem", "Die Kontrolle der Verbraucher über ihre persönlichen Daten ist das Herzstück der Verbraucher Privatsphäre<hr>", true, ["Stimme ganz <br>und gar nicht zu", "stimme <br>nicht zu", "stimme eher <br>nicht zu", "neutral", "stimme <br>eher zu", "stimme zu", "Stimme ganz <br>und gar zu"]),
            new QuestionnaireItemDefinedOne("questionnaireItem", "Ich glaube, dass die Online-Privatsphäre verletzt wird, wenn die Kontrolle verloren geht oder unfreiwillig reduziert wird als Ergebnis einer Marketing-Transaktion.<hr>", true, ["Stimme ganz <br>und gar nicht zu", "stimme <br>nicht zu", "stimme eher <br>nicht zu", "neutral", "stimme <br>eher zu", "stimme zu", "Stimme ganz <br>und gar zu"]),
        );
        screens.push(screen40);

        var screen43 = new ScreenUIElements(
            new UIElementHTML(undefined, "<h1>Demographics</h1>"),
            new QuestionnaireItemDefinedOne("questionnaireItem", "Zu welcher Alterskategorie gehören Sie?<hr>", true, ["18-20", "21-29", "30-39", "40-49", "50-59", "60 oder älter"]),
            new QuestionnaireItemDefinedOne("questionnaireItem", "Was ist Ihr Geschlecht?<hr>", true, ["Divers/Andere", "Weiblich", "Männlich"]),
            new QuestionnaireItemText("questionnaireItem", "Bitte geben Sie an in welchem Feld/Fachrichtung Sie tätig sind:<hr>", true),
            new QuestionnaireItemDefinedOne("questionnaireItem", "Üben oder übten Sie je einen Beruf in einem der folgenden Tätigkeitsfelder aus?<hr>", true, ["Informatik", "Elektrotechnik", "Kommunikationstechnik", "Ähnliches", "Nichts Ähliches"]),
            new QuestionnaireItemDefinedOne("questionnaireItem", "Was ist Ihr höchster erreichter Schulabschluss?<hr>", true, ["kein Abschluss", "Hauptschul- / Volksschulabschluss", "Realschulabschluss / Polytechnische Oberschule", "(Fach-) Abitur", "Hochschulabschluss"]),
            new QuestionnaireItemDefinedOne("questionnaireItem", "Welche der folgenden Kategorien beschreibt Ihren Beschäftigungsstatus am besten?<hr>", true, ["Auszubildende*r", "Student*in", "Angestellte*r", "Selbstständige*r", "Beamter/Beamtin", "Rentner*in / Pensionär*in", "Arbeitslose*r", "Sonstiges"]),
            new QuestionnaireItemDefinedOne("questionnaireItem", "Wie hoch ist Ihr jährliches Haushaltseinkommen (Brutto)?<hr>", true, ["Weniger als 20.000€", "20.000-34.999€", "35.000-49.999€", "50.000-74.999€", "75.000-99.999€", "Über 100.000€", "Ich möchte nicht antworten"]),
            );
        screens.push(screen43);

        screensAll = [...screensFirstWTA, ...screensShuffleWTA, ...screensShuffleWTP, ...screens];

        //posts data to server
        screensAll.push(new ScreenWaitDataUpload(undefined, HOST+"/receivedata_part2/"));
        //displays a message and link to the map
        //screensAll.push(new ScreenWait(undefined, undefined, "Thank you for taking part in the first part of our survey!<br>Click on the arrow button below to get to the map and the second part of the survey <br>Please take part in the second survey, in order to throughly participate in our survey.<br><a href='"+HOST+"/map/'>-->"));
        screensAll.push(new ScreenWait(undefined, undefined, "<h1>Vielen Dank für die Teilnahme an der Studie! </h1> <br><br> Sie haben nun alle Teile der Studie erfolgreich abgeschlossen. <br> Wenn Sie möchten, können Sie wieder zurück zur Map und sich ihre Übersicht in Ruhe noch einmal ansehen.<br>  <button onclick='goToMap()'>zurück zur Map!</button>"
        ));
        //Download Lokal
        //screensAll.push(new ScreenWaitDataDownload(undefined, "The End<br>All data should now be downloaded (incl. changes of questionnaireItems and their final answers).", "TheFragebogen-basic.csv", true));
        

        //Most important: create the ScreenController
        var screenController = new ScreenController(screensAll);

        </script>

        <script>
        //Having the start()-function in an extra script-tag makes sure that it will be executed even if there are errors in the script-tag configuring TheFragebogen.
        function start() {
            document.body.innerHTML += "TheFragebogen loaded. It works till here";
            if (typeof(screenController) === "undefined") {
                document.body.innerHTML += "<br><i>Something went wrong:</i> Please check that thefragebogen.js was loaded and that the configuration is ok.";
                return;
            }
            screenController.init(document.body);
            screenController.start();
        }

        function goToMap(){
            window.location.href=''+ HOST+''+'/map/';
        }
        
        </script>
    </head>

    <body onload="start()">
        <p>
            TheFragebogen will be shown here.<br> If something fails while starting, an error message will be shown here.
        </p>
    </body>

</html>
